'''
poUIrup v4.2.0b
Qianlang Chen
F 05/21/21
'''
import sys
from threading import Thread
from typing import List, Tuple

if sys.platform == 'win32':
  from pynput.keyboard import _win32 as keyboard
  from pynput.keyboard._win32 import Key, KeyCode
  from pynput.mouse import _win32 as mouse
elif sys.platform == 'darwin':
  from pynput.keyboard import _darwin as keyboard
  from pynput.keyboard._darwin import Key, KeyCode
  from pynput.mouse import _darwin as mouse
else:
  from pynput.keyboard import _xorg as keyboard
  from pynput.keyboard._xorg import Key, KeyCode
  from pynput.mouse import _xorg as mouse

class App:
  IS_WINDOWS = sys.platform == 'win32'
  IS_MAC_OS = sys.platform == 'darwin'
  IS_LINUX = not IS_WINDOWS and not IS_MAC_OS
  
  def start():
    Keyboard.init()
    Thread(target=Keyboard.start).start()
    # Thread(target=Mouse.start).start()

class Keyboard:
  MOD_SHIFT = 1 << 0
  MOD_CTRL = 1 << 1
  MOD_ALT = 1 << 2
  MOD_CMD = 1 << 3
  MOD_FN = 1 << 4
  MOD_SPEC = 1 << 5
  MOD_TOG = 1 << 6
  _MODS = {
    MOD_SHIFT: Key.shift.value.vk,
    MOD_CTRL: Key.ctrl.value.vk,
    MOD_ALT: Key.alt.value.vk,
    MOD_CMD: Key.cmd.value.vk,
  }
  # Loaded in init():
  GRAVE = ONE = TWO = THREE = FOUR = FIVE = SIX = SEVEN = EIGHT = NINE = -1
  ZERO = DASH = EQUAL = Q = W = E = R = T = Y = U = I = O = P = LEFT_SQUARE = -1
  RIGHT_SQUARE = BACK_SLASH = A = S = D = F = G = H = J = K = L = -1
  SEMICOLON = APOSTROPHE = Z = X = C = V = B = N = M = COMMA = DOT = -1
  FORWARD_SLASH = -1
  # mods -> (in_key -> (out_key, should_press_shift))
  _NORMAL_LAYOUT: Tuple[List[Tuple[int, bool]]] = tuple(
    [None] * 2**8 for _ in range(2))
  _IS_KEY_SHIFT_LOCKED = [False] * 2**8
  
  pressed_mods = 0
  shift_lock = False
  _controller: keyboard.Controller = None
  _listener: keyboard.Listener = None
  _ignore_count = 0
  _pressed_key = [-1] * 2**8 # in_key -> out_key
  
  def init():
    exec(open('config/mac_os_default.py').read())
  
  def start():
    Keyboard._controller = keyboard.Controller()
    Keyboard._listener = keyboard.Listener(
      on_press=Keyboard._handle_listener_press,
      on_release=Keyboard._handle_listener_release,
      suppress=True)
    Keyboard._listener.start()
    Keyboard._listener.join()
  
  def press_char_key(in_key: int):
    in_shift = bool(Keyboard.pressed_mods & Keyboard.MOD_SHIFT)
    if Keyboard.shift_lock and Keyboard._IS_KEY_SHIFT_LOCKED[in_key]:
      in_shift = not in_shift
    out_key, out_shift = Keyboard._NORMAL_LAYOUT[int(in_shift)][in_key]
    Keyboard.press_combo(out_key, int(out_shift))
    Keyboard._pressed_key[in_key] = out_key
  
  def press_combo(out_key: int, out_mods: int):
    Keyboard._touch_mod(True, out_mods)
    Keyboard._touch_key(True, out_key)
    Keyboard._touch_mod(False, out_mods)
  
  def _get_virtual(key_obj):
    return key_obj.value.vk if isinstance(key_obj, Key) else key_obj.vk
  
  def _touch_mod(should_press, out_mods):
    for mod, mod_key in Keyboard._MODS.items():
      if bool(out_mods & mod) != bool(Keyboard.pressed_mods & mod):
        Keyboard._touch_key(should_press == bool(out_mods & mod), mod_key)
  
  def _touch_key(should_press, out_key):
    # Pynput listener also unavoidably captures key touches generated by the
    # software itself, so some special platform-dependent work is needed here
    # and after the touch to disable temporarily and re-enable the listener.
    if App.IS_WINDOWS:
      Keyboard._ignore_count += 1
      Keyboard._listener._suppress = False
    elif App.IS_MAC_OS:
      # Hacked _tap
      keyboard.Quartz.CGEventTapEnable(Keyboard._listener._tap, False)
    else:
      raise NotImplementedError()
    
    Keyboard._controller.touch(KeyCode.from_vk(out_key), should_press)
    
    if App.IS_MAC_OS:
      keyboard.Quartz.CGEventTapEnable(Keyboard._listener._tap, True)
  
  def _should_ignore_listener_event():
    if Keyboard._ignore_count == 0: return False
    Keyboard._ignore_count -= 1
    if Keyboard._ignore_count == 0:
      if App.IS_WINDOWS: Keyboard._listener._suppress = True
    return True
  
  def _handle_listener_press(key_obj):
    if Keyboard._should_ignore_listener_event(): return
    if key_obj == Key.f11: raise KeyboardInterrupt()
    in_key = Keyboard._get_virtual(key_obj)
    if (Keyboard.pressed_mods & ~Keyboard.MOD_SHIFT == 0 and
        Keyboard._NORMAL_LAYOUT[Keyboard.pressed_mods][in_key] is not None):
      # Character key; normal
      Keyboard.press_char_key(in_key)
      return
    # Input key is unrecognized; default behavior: press normally
    print(f'Unrecognized key: 0x{in_key:02x}')
    Keyboard.press_combo(in_key, Keyboard.pressed_mods)
    Keyboard._pressed_key[in_key] = in_key
  
  def _handle_listener_release(key_obj):
    if Keyboard._should_ignore_listener_event(): return
    in_key = Keyboard._get_virtual(key_obj)
    if Keyboard._pressed_key[in_key] != -1:
      Keyboard._touch_key(False, Keyboard._pressed_key[in_key])
      Keyboard._pressed_key[in_key] = -1

class Mouse:
  _controller: mouse.Controller
  _listener: mouse.Listener
  
  def start():
    Mouse._controller = mouse.Controller()
    Mouse._listener = mouse.Listener(on_click=Mouse._handle_controller_click,
                                     on_move=Mouse._handle_controller_move,
                                     on_scroll=Mouse._handle_controller_scroll)
    Mouse._listener.start()
    Mouse._listener.join()
  
  def _handle_controller_click(x, y, button, press):
    print('Click x', x, 'y', y, 'button', button, 'press', press)
  
  def _handle_controller_move(x, y):
    print('Move x', x, 'y', y)
  
  def _handle_controller_scroll(x, y, dx, dy):
    print('Scroll x', x, 'y', y, 'dx', dx, 'dy', dy)

if __name__ == '__main__': App.start()
